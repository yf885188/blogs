<!-- TOC -->

- [1. 帧资源](#1-帧资源)
  - [1.1. 原因](#11-原因)
  - [1.2. 原理](#12-原理)
- [2. 渲染项](#2-渲染项)
- [3. 常量数据分类](#3-常量数据分类)
- [4. 生成多种不同的几何体](#4-生成多种不同的几何体)
- [5. 场景内容绘制](#5-场景内容绘制)
  - [5.1. 多物体绘制](#51-多物体绘制)
- [6. 根签名](#6-根签名)
  - [6.1. 根参数](#61-根参数)
- [7. 动态顶点缓冲区](#7-动态顶点缓冲区)

<!-- /TOC -->

# 1. 帧资源
## 1.1. 原因
原有框架的问题：
- 每帧的CommandAllocator不能跨帧分别给CPU写入和GPU读取
- 每帧的Constant Buffer不能跨帧分别给CPU写入和GPU读取

为解决上面的问题,每帧头尾FlushCommandQueue。又带来了CPU跟GPU分开空闲，利用率低的问题。

所以引入了帧资源。

## 1.2. 原理
把每帧需要更新的常量缓冲区数据以及CommandAllocator分装成帧资源，多个帧资源组成一个环形队列，CPU提前几帧把帧资源更新好放入帧资源队列中，GPU自取进行处理。

# 2. 渲染项
渲染资源的CPU扩展结构。

# 3. 常量数据分类
- PerPass
- PerObject

# 4. 生成多种不同的几何体
- 柱体网络
- 球体网络
- 几何球体网格：同样大小的等边三角形生成。可以关注下生成算法。

# 5. 场景内容绘制
## 5.1. 多物体绘制
- 顶点缓冲区和索引缓冲区的合并
- 帧资源和常量缓冲区

# 6. 根签名
## 6.1. 根参数
最多占用64DWORD
- 描述符表：描述符堆中的一块连续多个资源内存区域。占1DWORD；
- 根描述符：绑定一个资源内存区域。只有CBV、SRV/UAV才可以，纹理的SRV不行。占2DWORD;
- 根常量：直接绑定的一系列32位的常量.占1DWORD;

# 7. 动态顶点缓冲区
使用上传缓冲区实现，跟PerPass的上传类似。