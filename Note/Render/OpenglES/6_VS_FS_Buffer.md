# 顶点属性
## 顶点属性存储方式
- 结构数组：单一顶点的所有属性都放在一个顶点的结构中，数组的每个元素是一个顶点属性结构
- 数据结构：每个属性都集中放在一个buffer，不同buffer表示的是不同属性的集合

> 出于局部性的原因，大部分情况下结构数组通常比数据结构更有效率。

## 顶点数组与常量

## 属性声明
包括： 
- in
- 布局限定符
注意：
- 不能修饰数组/结构
- 属性不进行打包，需要的话，手动进行打包

## CPU端的顶点属性 -> GPU端的属性变量
分类：
- 顶点数组 -> VAO
- 顶点缓冲区对象

## 顶点数组方式
方式：
- 通过索引和layout限定符绑定
- 应用程序可以将顶点属性索引绑定到属性名称:glBindAttribLocation
- opengl es把**通用顶点属性索引**绑定到属性名称：没有通过第二种方式绑定的顶点属性会被默认分配一个通用的顶点属性索引，通过glGetAttribLocation获取



## 顶点缓冲区对象
优化顶点属性的数据提交。

两类缓冲区对象：
- 数组缓冲区对象：顶点数据的缓冲区对象。Vertex等
- 元素数组缓冲区对象：图元索引的缓冲对象。Indice

### 使用
- glGenBuffers
- glBindBuffers
- glBufferData/glBufferSubData

## VAO 顶点数组对象
- glGenVertexArrays
- glBindVertexArray

> 相比之前的顶点数组，每次都是直接通过offset绑定CPU端的内存从而绑定顶点属性。而顶点数组对象是通过状态在GPU端进行属性值的绑定。
> 区别就是，一个是在CPU端计算内存映射的方式；一个在GPU端通过设置属性状态来达到效果。
> 相比之前，跟顶点缓冲区对象一样，减少了CPU和GPU的通信达到优化性能的目的

## 三种方式的比较
- 顶点数组：CPU端一块内存算偏移，映射顶点属性到GPU端
- 顶点缓冲区对象：CPU端两块内存，分别映射到GPU端的不同类型缓冲区
- 顶点数组对象：CPU一块内存直接映射，通过在GPU端切换状态获取不同的顶点属性

# 映射缓冲区对象
相比glBufferData/glBufferSubData的好处：
- 数据复用，减少内存占用
- 共享内存可以避免复制步骤，提高效率

> ~~我的理解是：每次的glBufferData/glBufferSubData都会在GPU端创建一次显存，但是映射的方式，直接是CPU内存地址到GPU内存地址的映射。如果有Sub CPU内存的分配时，前者会在Sub CPU内存的“父内存”对应的GPU内存之外创建一块新的显存，而后者则是直接从现有的显存中获取映射后的地址进行返回。~~(存疑)前者需要数据copy？后者潜在表达的是，CPU端和GPU端两侧的物理内存存储方式一致？

使用glFlushMppedBufferRange指定更新映射后的区域，减少性能消耗。

# 赋值缓冲区对象
glCopyBufferSubData:GPU端的内存复制