<!-- TOC -->

- [1. 调研](#1-调研)
- [2. 目标](#2-目标)
- [3. 案例](#3-案例)
  - [3.1. 细胞分裂的解决方案](#31-细胞分裂的解决方案)
    - [3.1.1. work flow](#311-work-flow)
    - [3.1.2. tradeoff](#312-tradeoff)
    - [3.1.3. Shadow Caster剔除](#313-shadow-caster剔除)

<!-- /TOC -->

[原文](./GPU%20Pro%202.pdf)

# 1. 调研
- PVSs(static potentially visible sets)
  - 缺点1： 所有可破坏/移动的物体都会被当做无遮挡。在不同区域间的话，会产生表现问题，为避免这些问题，通常会限制关卡的设计
  - 缺点2：生成PVS的预计算耗时耗力，影响开发
- Portals：通过一些入口等设置来连接各区域，然后各入口配合相机的视锥裁剪自己进行视锥裁剪
  - 适用于各种室内环境
- AntiPortals：利用物体生成的凸包去剔除他们后面的物体
  - 缺点：在开放区域，考虑到性能影响的话，每帧只能使用少量的凸包做AntiPortals
- occluder fusion:融合多个antiportals做遮挡
  - 缺点：也是消耗太大
- occlusion queries:渲染场景中一个子集的深度，然后把他们的包围盒光栅化，然后把得到的结果作为测试的标准，使用GPU做深度测试（比如：Hi-Z？）
  - 优点1：适用于更大的场景
  - 优点2：适用于场景中的变化
  - 优点3：遮挡的组合处理也很轻松
  - 缺点1：合批。虽然同一时间能进行多次query，但是不能把多个包围盒用单个query合批到一个draw call中
  - 缺点2：延迟。虽然有很多方式——比如分层、BVH（bounding volume hierarchy）和八叉树等方式——来降低延迟。但是这种方式依然存在CPU-GPU的同步问题，一般情况下，可以把query和rendering工作进行并行操作，但是这样的话，又会导致更复杂的渲染设计
  - 缺点3：popping现象。也可以在正确性上进行妥协，采用latent queries的方式，在下一帧延迟检查OQ的结果，但是这样的话，会导致“popping”现象——物体突然出现，而不是一点点进入视线内。
  - 缺点4：性价比。为了表现逼真的画面效果，GPU的负载一直都很大。除非OQ能节省大量的GPU算力，那不如把GPU算力全给直接渲染。
  - 缺点5：成本不可控。OQ的成本跟几何体在屏幕上的尺寸有关。分层的设计对CPU有多余负载。
  
# 2. 目标
使用OQ，但是要做改进，把传统OQ的缺点尽量弱化。

首要考虑：
- 不要预计算
- 普遍适用性
- occluder fusion：遮挡融合

主要目标：
- 低延迟
- 减少CPU-GPU的相互依赖
- 不依赖一致性
- 有界，高性能
- 简单，统一的解决方案

# 3. 案例
## 3.1. 细胞分裂的解决方案
使用Hi-Z的解决方案，可以参考[Greene93](../Hi-Z/Note__Hi-Z.md)

### 3.1.1. work flow
- 绘制occluder的深度：最开始是由artist出于性能考虑设计的。
- 创建depth层次：参考[Greene93](../Hi-Z/Note__Hi-Z.md)
  - 根据设置的depth buffer的大小，可能有一些小尺寸的像素会被错误的剔除，但是这种小的尺寸剔除本来也在计划内，所以不影响大局
- 测试object的bounds：具体代码可以看原文
  - [VS]把世界空间的AABB投射到屏幕空间AABB
  - [VS]根据屏幕空间AABB的宽和高来确定采样的depth等级：$level = ceil(log_2(width, height))$。保证像素采样的时候是相邻/同一个的两个像素
  - [PS]采样2x2的Z深度中的最大值与VS中计算的屏幕空间AABB最小Z值进行比较并判断遮挡
- 获取结果
  - Xbox360通过MemExport
  - DX10中通过把渲染的结果传给一个点大小的离屏render-target，然后通过GetRenderTargetData把数据copy到系统内存

### 3.1.2. tradeoff
- 实际上是通过降低屏幕上尺寸较大物体的准确性的代价来达到一个可控的表现（根据屏幕空间AABB四个采样点跟屏幕空间AABB最小Z的值来判断）。
- 大的物体总会被绘制，使用传统OQ的方式会浪费更多算力（每个像素都做了OQ?）。Hi-Z的话，按屏幕空间的占用比例分配可见性，更合适。在很多情况下的可以使用这种方式把很多杂乱的小物体给剔除掉。
- 每个物体一次的query粒度比OQ有时候需要聚合查询的粒度更友好

### 3.1.3. Shadow Caster剔除
用两个pass来完成这个效果：
- 第一个pass：在光源空间创建Hi-Z，并用其剔除caster。并记下可视caster的最近位置和最远位置。
- 第二个pass：把上一个pass记录的两个位置变换到相机空间下的Hi-Z进行比较，进行同样的剔除操作。