<!-- TOC -->

- [1. 摘要](#1-摘要)
- [2. 简介](#2-简介)
- [3. 调研](#3-调研)
- [4. 理论](#4-理论)
- [5. 模型空间八叉树](#5-模型空间八叉树)
- [6. 屏幕空间Z pyramid](#6-屏幕空间z-pyramid)
- [7. 时间相干性列表](#7-时间相干性列表)

<!-- /TOC -->


[原文](./greene93.pdf)

# 1. 摘要
一个理想的可视化算法需要满足两个标准：
- 快速的剔除掉一个模型中隐藏的图元
- 能够充分利用已生成纹理的空间和时间局部性/相干性/一致性

Ray Cast满足第一条，不满足第二条；
传统的Z Buffer算法满足了第二条，不满足第一条。

本文提出的Hi-Z scan-conversion算法能满足全部的两条标准。

Hi-Z scan-conversion算法使用了两层数据结构来加速scan-conversion：
- 模型空间八叉树
- 屏幕空间Z pyramid（棱锥）

这种两层结构能使用scan-conversion的速度在绘制可见图元的时候快速提出掉隐藏的图元。

对于动画，这个算法也能利用时间相干性。

总结：
这种方式非常适合深度上有很强复杂性的模型，相对于传统的Z-buffer scan-conversion有数量级上的提升。

# 2. 简介
至少有三种相干性能用来加速可视算法：
- 模型空间相干性：很多情况下，一次计算就能解决一个空间内一个相邻物体图元的可视性
- 屏幕空间相干性：一次计算，能解决一大票像素的可视性
- 时间相干性：上一帧的画面常常能用来加速下一帧画面的可视性计算

传统Z-Buffer的优缺点：

优点：
- 能从屏幕空间相干性上节省大量的计算成本

缺点：
- 没有利用其它两类相干性
- 每个图元都是独立渲染
- 也没有保存前一帧的相关信息
- 对于复杂的模型/场景很低效

Ray casting/tracing的优缺点：

优点：
- 只关心最前面的面

缺点：
- 没有利用时间相干性和屏幕空间相干性

Hi-Z 算法结合了上面两种算法的优点：
- 模型空间相干性：使用空间八叉树来加速Ray Tracing
- 屏幕空间相干性：使用屏幕空间Z pyramid来替代传统Z-buffer来做剔除
- 时间相干性：我们使用上一帧中一个可见的图元来为这个算法创建一个starting point

# 3. 调研
省略，详细可以参看原文。

# 4. 理论
# 5. 模型空间八叉树
八叉树用来检测遮挡的递归流程：
- 检测八叉树cube是否又跟视锥相交
  - 不相交则直接剔除
- 相交在看cube的6个面是否有被遮挡
  - 如果都被遮挡则也直接剔除
- 如果没有全被遮挡，然后从前往后接着递归

八叉树的递归建造过程：
- 能紧凑包裹所有模型和图元的根节点
- 如果图元的数量很少，则只用把所有的图元用cube包裹加到节点然后退出
- 反之把任何跟二分当前节点的轴平行平面用cube包裹（意即：跟这些轴平行平面相交的图元就不能接着划分子节点）
- 依次迭代下去构建当前节点的8个子节点

优势：
- 只会渲染八叉树中的可见节点
- 相对于传统的视锥剔除很大的提升
- 不会在不相关的地方浪费时间
- 每次渲染的时候，每个八叉树的节点只访问一次
  - 传统Ray tracing对八叉树进行遍历：每个像素都会访问根节点一次，其他每个节点也会被访问很多次

缺点：
- 小的图元可能会有比较大的Cube
  - 极端情况下，一个小的三角形穿透了根节点的中心，基本上这个八叉树就无效了

为了解决上面说的这种问题，通常有两种解决方案：
- 把出问题的这些结合体给裁减掉
- 另外一种情况是在多个八叉树节点里面重复放置图元

本文选择第二种方案。

并在流程中做如下修改：
- 如果发现一个图元跟cube的分割面相交，先比较当前图元跟分割面的大小关心
  - 如果远远小于cube，那么接着分割。并把这个图元放到所有相交的子节点中。在后面渲染的时候也可以进行优化，如果渲染完成则不需要二次渲染
  - 如果差不多大，那么就停止分割

# 6. 屏幕空间Z pyramid
用来优化八叉树的检测速度。

构建：
- 使用原始的Z buffer作为pyramind中最好的一层
- 合并4个Z值（选择4个Z中最远的值）到下一层比较粗糙的层中
- 最后一层的最后一个值则是整个image中离Z最远的那个值

> 维护的时候，只需要按照上面的顺序更新一次就好，直到最后一层，或者当前层的值已经比更新的值要大

使用：

递归比较深度，从顶层塔尖开始。

这套比较中存在的比较耗时的操作就是确定几何体的最近距离。本文的操作是，如果当没法确定一个集合体是否会被遮挡的时候，我们就会使用原有的操作进行可见性判断。

# 7. 时间相干性列表
维护一个时间相干性列表，把前一帧可见的cube放到这个列表中，当前帧更新的时候，先把这个列表中的cube渲染了，并初始化当前的Z pyramid，这样当前场景中其他的cube渲染会很快的通过测试，从而达到利用时间相干性提速的目的。

