<!-- TOC -->

- [1. 简介](#1-简介)
- [2. 调研](#2-调研)
- [3. 架构](#3-架构)
- [4. 遮挡纹理](#4-遮挡纹理)
  - [4.1. ImagePyramid](#41-imagepyramid)
  - [4.2. 快速构建](#42-快速构建)
  - [4.3. 特性](#43-特性)
- [5. 使用HOM进行可视性剔除](#5-使用hom进行可视性剔除)
  - [5.1. 重叠测试](#51-重叠测试)
  - [5.2. 深度比较](#52-深度比较)
    - [5.2.1. 单Z平面](#521-单z平面)
    - [5.2.2. 深度估计缓存](#522-深度估计缓存)
  - [5.3. 遮挡物的选择](#53-遮挡物的选择)
    - [5.3.1. database的选择标准](#531-database的选择标准)
    - [5.3.2. 动态选择](#532-动态选择)
  - [5.4. 近似可见性剔除](#54-近似可见性剔除)
  - [5.5. 动态环境](#55-动态环境)

<!-- /TOC -->

[原文](./Visibility%20Culling%20using%20Hierarchical%20Occlusion%20Maps.pdf)

# 1. 简介
该算法的主要特色：
- 通用性强：
- 遮挡物聚合
- 大量剔除
- 可移植性：主要问题是在read back的能力上。
- 高效
- 近似可见性剔除：使用层级map

# 2. 调研
详细参看原文。

# 3. 架构
核心：
- 遮挡纹理的层级结构：记载了遮挡物集合映射到不同分辨率纹理上的投影。把可视性问题解耦成两个子问题：
  - 二维的覆盖测试问题
  - 深度测试问题

work flow:

<div align="center">

![][HOMWorkFlow]

</div>

# 4. 遮挡纹理
遮挡纹理：一个二维数组，每个像素记载了屏幕空间一块矩形区域的不透明度。

屏幕空间矩形块的不透明度表示矩形块中不透明区域大小占矩形块所有区域大小的比例。代表了遮挡的几率。

> Hi-Z 中记录的是最大的Z值

## 4.1. ImagePyramid

<div align="center">

![][HOMImagePyramid]

</div>

## 4.2. 快速构建
- 使用2x2的像素块：很多硬件支持双线性插值，以此提高速度。
  - 使用这种采样也会花时间，当要生成的遮挡纹理比较小的时候，这种方式的性价比就不太高了。


## 4.3. 特性
- 遮挡物融合
- 层级遮挡测试
- 高水平的不透明评估：根据像素代表的遮挡几率进行重叠测试的早期剔除
- 近似可视性剔除：

# 5. 使用HOM进行可视性剔除
## 5.1. 重叠测试
跟[Hi-Z](./../Hi-Z/Note__Hi-Z.md)类似,不过此时用的是采样的像素值来表示遮挡的几率，只有当像素值小于设定的阈值时，才表示当前不会被遮挡。而Hi-Z中是通过深度值与采样值进行的比较。

## 5.2. 深度比较
两种方式。
### 5.2.1. 单Z平面
新建一个原理近平面但是与其平行的Z平面，把遮挡物和潜在的被遮挡物分开。
### 5.2.2. 深度估计缓存
把屏幕空间中像素进行分区，然后并行地计算当前分区合适的深度值用来做深度的判断。
  - 正确的做法是保存深度信息，然后靠像素对应的深度信息进行判断，但是这涉及到一个硬件的支持问题

## 5.3. 遮挡物的选择
### 5.3.1. database的选择标准
- 尺寸：除非离观察者很近，不然小的物体一般不当遮挡物
- 冗余性：跟现有的遮挡物判断有重叠的
- 渲染复杂度：复杂度太高的也不合适

### 5.3.2. 动态选择
- 根据深度比较中的单Z算法进行选择
- 根据深度估计缓存+几何体的面片数量限制一起决定

## 5.4. 近似可见性剔除
- 不透明度阈值
- 为了保证比较一致的近似效果，随着遮挡贴图的层级越高，阈值也应该越大

## 5.5. 动态环境
- 算法很容易扩展到动态环境（...）
- 使用OBB

> 个人认为这种算法相比Hi-Z算法丧失了通用性，在复杂场景中的处理还可以，但是在一些简单场景，比如房间内的场景等，很容易出现错误剔除的情况。反正通篇看下来一言难尽……

[HOMWorkFlow]: ./HOMWorkFlow.jpg
[HOMImagePyramid]: ./HOMImagePyramid.jpg