<!-- TOC -->

- [1. 基本定义](#1-基本定义)
- [2. 纹理管理](#2-纹理管理)
  - [2.1. 面临的问题](#21-面临的问题)
  - [2.2. 传统的解决方案](#22-传统的解决方案)
  - [2.3. AGP纹理](#23-agp纹理)
  - [2.4. Virtual Texture](#24-virtual-texture)
    - [2.4.1. 优点](#241-优点)

<!-- /TOC -->

[原文](./Note__VirtualTexturing.md)

# 1. 基本定义
- 纹理
- mipmap
- 纹素

# 2. 纹理管理
## 2.1. 面临的问题
都是基于1999年论文发表时的数据
- 纹理在内存的保存是一个经典的NP问题
- 纹理的存储会消耗大量的内存
  - 单纹理占用很多内存
  - 程序会使用很多纹理
- 为了最好的效率，纹理要驻留在显卡上
  - 每画一个像素，最多访问8个纹素
  - 读取纹素有4GB的带宽限制等
- 内存格式和尺寸有限制
- read back有限制

## 2.2. 传统的解决方案
两个链表，free list和used list，类似于CPU端的内存管理。

<div align="center">

![][TraditionalManagement]

</div>

存在的问题：
- 空间的浪费
- 垃圾回收问题
- 局部性问题
- 有额外负担
- 载入全部的纹理，所有的mipmap

## 2.3. AGP纹理
- 解决上文提出的问题
- 存在纹理访问延迟
  - 当总线中有纹素数据在传输的时候需要暂停整个纹理管线
- 每使用一个纹素，就会产生一次AGP总线的传输
- 会跟顶点传输有冲突
- 不效率，太费算力

<div align="center">

![][AGP]

</div>

## 2.4. Virtual Texture
<div align="center">

![][VTStructure]

架构

</div>

技术细节：
- 操作的基本单位是4KB的页
  - 32x32的真彩色
  - 小纹理能被合并到单页中
  - AGP总线操作的基本数据大小
- 最高256MB的纹理数据
  - 每页8B的页表消耗
  - 256MB使用512KB的板上内存
- 真正的按需分配页内存的纹理管理方式
  - 纹理不用常驻内存
  - 只有需要的纹理才会被带入显卡
- 纹理在显卡和内存中都不需要连续存储
- 不需要CPU介入

### 2.4.1. 优点
- 降低了纹理加载的负载
- 根据需要加载对应mipmap的纹理
  - 不靠近的话，能减少高精度的加载
  - 靠近的话，能平滑加载
- 程序能很简单的定义纹理在内存和显卡中的映射位置
- 不需要CPU的参与
- 可以使用超出硬件内存的纹理
- 很容易操作上千个小纹理
- 能够阔爱站到系统虚拟内存

[TraditionalManagement]: ./TraditionalManagement.jpg
[AGP]: ./AGP.jpg
[VTStructure]: ./VTStructure.png