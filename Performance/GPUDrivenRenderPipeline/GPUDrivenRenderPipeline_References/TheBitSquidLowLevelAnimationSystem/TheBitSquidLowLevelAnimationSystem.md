<!-- TOC -->

- [1. 原理](#1-原理)

<!-- /TOC -->

[原文](http://bitsquid.blogspot.com/2009/11/bitsquid-low-level-animation-system.html)

# 1. 原理
在BitSquid引擎中存在两类动画系统：
- 低级系统：给定动画数据，找到在时间t的骨骼位置
- 高级系统：姿势混合，状态机，ik

动画计算是一个内存密集型的任务，要最大化表现意味着：
- 接触越少的内存越好（压缩动画）
- 内存局部性要好

BitSquid中的动画压缩：
- 曲线拟合
- 数据量化

使用曲线拟合的好处：
- 把错误控制到一个阈值一下
- 曲线的表现很小
- 曲线很光滑
- 计算快

work flow:

<div align="center">

![][WorkFlow]

</div>

解决误差的方式：
- 找到有最大误差的间隔$D_i$和$D_{i+1}$
- 通过在$(t_i + t_{i+1})/2$处添加新的数据点来把误差给平均下去

> 此外
> - 分离点选得越好，压缩率越好
> - 在同一点插入两个不同的数据点也能支持曲线的不连续性

动画压缩既可以在局部空间（关节空间）做也可以在全局空间做。

在全局空间做的好处：
- 不会有累计误差：通过骨骼绑定层次，不会把误差放大
- 全局空间做的动画能更复杂，这样的动画也更难压缩

在全局空间做的劣势：
- 不过也更费算力
- 通常做姿势混合，也还是会转到局部空间

数据结构：
- Vector3:每个分量16bits
- 四元数：
  - 2bits：最大的分量索引
  - 10bits:剩下的3个分量每个所用的位数 
  - 因为4个分量有$x^2 + y^2 + z^2 + w^2 = 1$，可以决定最大的分量具体是多少，以及精度可以用10bits来表示。

> 总共的内存消耗
> - 曲线点： Vector3: 48bits 
> - 四元数曲线点： 32bits
> - 时间戳：16bits


[WorkFlow]: ./BSLLASWorkFlow.png

