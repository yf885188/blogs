<!-- TOC -->

- [1. 优劣](#1-优劣)
- [2. 数据基本结构](#2-数据基本结构)
- [3. 优化细节](#3-优化细节)
  - [3.1. 大部分关于光源的优化](#31-大部分关于光源的优化)
  - [3.2. G-Buffer创建优化](#32-g-buffer创建优化)
  - [3.3. ShadowMapping的优化](#33-shadowmapping的优化)
- [4. 质量提升trick](#4-质量提升trick)
  - [4.1. virtual position](#41-virtual-position)
  - [4.2. 环境光遮蔽](#42-环境光遮蔽)
  - [4.3. 材质与表面光的交互](#43-材质与表面光的交互)
- [5. AA](#5-aa)

<!-- /TOC -->

原文是GPU Gems 2 的第9篇——Deferred Shading In S.T.A.L.K.E.R.

# 1. 优劣
- 直接渲染平行光的话，不是很效率
- 有些传统的优化技术在延迟渲染中无效
- 无法解决透明物体的渲染，还是要依靠之前的方式对透明物体进行渲染。（也无法引用深度剥离技术）
  
# 2. 数据基本结构
16个材质属性，一共4x4个float：
- albedo: 3
- normal: 3
- position：3
- gloss: 1
- 材质ID：1
- 环境光遮蔽：1
- gloss：1

# 3. 优化细节
## 3.1. 大部分关于光源的优化
- 光源要产生阴影吗？
  - 可能回影响GI
- 光源需要有投影的表现吗？
  - 可以跟shadow map投影使用一样的矩阵？
- 光源需要在透明表面上投射阴影吗？
  - 透明表面的数量；
  - 投影和透明能不能合并处理。
- 光源是否要镜面光表现
- 光源移动吗？
  - 使用预计算的shadow-caster可见性数据来计算光源——pvs

太阳光
- 天空盒不需要画
- 背向太阳的不用画
- 被其他物体遮挡的不用画

## 3.2. G-Buffer创建优化
更多的是针对硬件进行的优化。包括Pos Buffer、Normal Buffer等在不同空间（Post-Projection Space/Eye Space）不同硬件下的指令调用次数，内存占用等的比较。

> sampling和decoding在很多情况下会比其他的属性更昂贵

## 3.3. ShadowMapping的优化
三种优化泛光灯的方式：
- 用CubeMap来记录距离光源中心的距离
- 使用2D展开的CubeMap
- 把点光源当做6个聚光灯，并分别渲染

# 4. 质量提升trick
## 4.1. virtual position
在相机空间，沿着当前点的normal轻微移动一下位置。

## 4.2. 环境光遮蔽
(细节还要找原始的参考论文看看，不太懂)
改用顶点数据存储ambient-occlusion factor。
主要的方式：
- 把原始的几何体细分到一个不变的边缘长度
- 然后使用自适应的细分，把边误差和三角形中心误差消除到一个比较小的边缘范围
- 基于Quadric Error Metric Algorithm
  - 在每一次迭代中使用三种简单的放置策略重新计算中间误差:边缘中间、第一和第二顶点。

## 4.3. 材质与表面光的交互
延迟渲染的好处：
- 所有信息都储存在light-shader中
- 整个世界都是被一个shade渲染的

为了保持帧率，我们把材质id绑定到一个光源相关的查找表中：
- 具体就是按照shininess排序，对材质进行分层，然后利用局部性加快读取。

# 5. AA
带边缘检测的Blur。
- 8+1的深度和法线检测

> 要注意这种方式受blur半径和分辨率的影响