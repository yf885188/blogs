
<!-- TOC -->

- [1. 传统的镜面反射实现](#1-传统的镜面反射实现)
- [2. SSR](#2-ssr)
  - [2.1. 原理](#21-原理)
  - [2.2. 求交步长问题](#22-求交步长问题)
  - [2.3. 相交判断](#23-相交判断)
- [3. 缺点](#3-缺点)

<!-- /TOC -->
# 1. 传统的镜面反射实现
配合模板测试和反射矩阵，把场景中所有的实体渲染一遍。

# 2. SSR
## 2.1. 原理
光线的可逆性
- 通过视点和平面上像素位置可以求得光线的入射方向；
- 通过入射方向的反方向跟实体进行求交获得交点，然后根据交点的屏幕空间颜色给反射点赋反射的像素值。

## 2.2. 求交步长问题
相机空间步进1单位，屏幕空间却不是，这样的话，并不能保证步进采样是连续的，就容易导致效果错误。

<div align="center">

![][SSRRayMarching]

</div>

因此就需要把屏幕空间步进1单位的长度反算回相机空间，然后进行求交。

[SSRRayMarching]: ./SSRRayMarching.jpg

## 2.3. 相交判断
根据当前步进点在裁剪空间中的深度与depth buffer中的采样值进行比较，如果深度比采样的深度略大于或者等于就保证相交了。

> 一个比较重要的问题是，如果实体是有厚度的，此时交点是物体的背面，就会出现问题：判断交点远大于采样点就会一直步长下去，采样到错误的像素。因此，这里需要把正面和背面都进行绘制，产生两套depth buffer和color buffer。


# 3. 缺点
- 效果上：都是基于屏幕空间进行的操作，被遮挡的物体也不会反应到反射上；
- 性能上：Ray Marching的这种方式太耗性能。
