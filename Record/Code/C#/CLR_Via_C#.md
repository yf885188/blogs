<!-- TOC -->

- [1. GC](#1-gc)
  - [1.1. 原则与假设](#11-原则与假设)
  - [1.2. 触发时机](#12-触发时机)
  - [1.3. work flow](#13-work-flow)
- [2. JIT](#2-jit)
  - [2.1. 类型对象](#21-类型对象)
  - [2.2. work flow](#22-work-flow)
- [3. 装箱与拆箱](#3-装箱与拆箱)
  - [3.1. 值类型与引用类型](#31-值类型与引用类型)
  - [3.2. 装箱](#32-装箱)
  - [3.3. 拆箱](#33-拆箱)

<!-- /TOC -->

# 1. GC
## 1.1. 原则与假设
- 对象越新，生存期越短
- 对象越老，生存期越长
- 回收堆的一部分速度要快于回收整个堆

## 1.2. 触发时机
- System.GC.Collect手动回收
- Windows报告内存过低
- CLR卸载Appdomain
- CLR正在关闭

## 1.3. work flow
CLR的GC一共有3代。
- 1. 新分配的内存都是第0代。
- 2. 当第0代的资源预算要用完了，就会触发GC，把第0代的资源中不需要的资源回收。剩下的内存资源进行压缩，然后都加入到第1代中。
- 3. 如果第1/2代的资源达到预算，也会触发GC，回收当代的资源，然后压缩，放到下一代中，但最多只到第2代。

> 对于重载了finalize的资源内存，会先放到一个finalize list中，触发GC之后会从finalize list中转移到freachable队列中，然后进行异步回收，并调用对应的finalize。在freachable中，还没有调用对应finalize方法的内存还不算垃圾，不会被回收。

# 2. JIT
## 2.1. 类型对象
每个实例对象，除了包含一般的实例数据以外，还包含：
- 同步块索引
- 类型对象指针

类型对象包含：
- 类型对象指针
- 同步块索引
- 接口信息

类型对象的类型对象指针指向type类型对象，而type类型对象的类型对象指针指向自己。

> - 创建好的类型对象都保存在loader堆。
> - 跟C++中的虚函数表类似

## 2.2. work flow
- 调用一个函数时，会从托管堆中查询是否有对应的代码段
  - 若没有，则通过元数据在对应程序集中查找相关的代码并编译（JIT），加载到托管堆中并调用
  - 若有，则直接调用

> JIT虽然有这种调用时的编译消耗，但是会针对不同的编译器进行各种优化，所以跟C++这种静态语言的效率还不好直接定义优劣。

# 3. 装箱与拆箱
## 3.1. 值类型与引用类型
- 值类型
  - 包括：枚举、结构、内置基本类型等
  - 在堆栈中，不会被GC，不通过指针引用
- 引用类型
  - 包括：string、类、接口、委托等
  - 在托管堆中，存在额外消耗的结构：类型对象指针和同步块索引。

## 3.2. 装箱
work flow:
- 分配堆内存
- 值类型的字段赋值到新分配的堆内存
- 返回对象地址

## 3.3. 拆箱
work flow:
- 获取引用类型的各字段地址
- 将各字段地址分配给值类型各字段(这一阶段严格来说不算是拆箱过程)
